---
id: draftrfcxmlrfcswl103k03
type: standard
schema_version: v1.4.1
title:
- language: en
  script: Latn
  content: SW103K PROTOCOL
source:
- type: src
  content: https://datatracker.ietf.org/doc/html/draft-rfcxml-rfc-swl-103k-03
docidentifier:
- content: draft-rfcxml-rfc-swl-103k
  type: Internet-Draft
- content: draft-rfcxml-rfc-swl-103k-03
  type: Internet-Draft
  primary: true
docnumber: I-D.rfcxml-rfc-swl-103k
date:
- type: published
  at: '2025-05-19'
contributor:
- role:
  - type: author
  person:
    name:
      forename:
      - language: en
        script: Latn
        content: Chazah
      - language: en
        script: Latn
        initial: C
      formatted_initials:
        language: en
        content: C.
      surname:
        language: en
        content: Group
      completename:
        language: en
        content: Chazah Group
    affiliation:
    - organization:
        name:
        - language: en
          content: Organization ChazahGroup
version:
- draft: '03'
language:
- en
script:
- Latn
abstract:
- language: en
  script: Latn
  content: "   What Problems Does This Protocol Solve?  The SW103k protocol\n   addresses
    several challenges that arise when transporting data over\n   networks with limited
    bandwidth, latency constraints, and data\n   integrity concerns.  Specifically,
    it provides a compression and\n   decompression mechanism designed to: Optimize
    Bandwidth Utilization:\n   In environments where bandwidth is limited, such as
    IoT networks,\n   satellite communications, and mobile data transfers, SW103k
    reduces\n   the amount of data sent over the wire by compressing data in transit,\n
    \  thus saving bandwidth.  SW103K Layer 2 Protocol Specification 1.\n   Protocol
    Stack Positioning text +-----------------------+ |\n   Application | +-----------------------+
    | HAVI | (Packet Format\n   Layer) +-----------------------+ | SW103K | (Data
    Link Layer)\n   +-----------------------+ | Physical Layer |\n   +-----------------------+
    2.  Frame Format 2.1 SW103K Header (Layer\n   2) text 0 1 2 3 0 1 2 3 4 5 6 7
    8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\n   7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Version | QoS | Batch ID |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Destination MAC |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Source MAC |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   EtherType (0x5W3K) | Payload Length |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   merklesw103k Root Hash | | (256-bit) |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    2.2\n   HAVI Packet Format (Encapsulated) text 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0\n
    \  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   HAVI Ver | Priority | Packet ID |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Timestamp |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Payload (972 bytes max) | | |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   CRC-16 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 3.  Layer 2 Implementation\n
    \  Examples 3.1 Linux Kernel Module (C) c struct sw103k_frame { u8\n   version;
    u8 qos; u16 batch_id; u8 dest_mac[ETH_ALEN]; u8\n   src_mac[ETH_ALEN]; u16 ethertype;
    u16 payload_len; u8\n   merklesw103k_root[32]; u8 payload[]; } __attribute__((packed));\n
    \  static netdev_tx_t sw103k_xmit(struct sk_buff *skb, struct net_device\n   *dev)
    { struct havi_packet *hp = (struct havi_packet *)skb->data;\n   struct sw103k_frame
    *sf; /* Batch 103 HAVI packets */ if (batch_count\n   == 103) { sf = alloc_skb(sizeof(struct
    sw103k_frame) +\n   compressed_size); build_merklesw103k_tree(batch,\n   sf->merklesw103k_root);
    lz77_compress(batch, sf->payload);\n   dev_queue_xmit(sf); } } 3.2 FPGA Implementation
    (Verilog) verilog\n   module sw103k_encoder ( input wire clk, input wire [972*8-1:0]\n
    \  havi_payload, output reg [1518*8-1:0] l2_frame ); reg [31:0]\n   merklesw103k_root;
    always @(posedge clk) begin // merklesw103k tree\n   computation merklesw103k_root
    less or equal sha3_256(havi_payload);\n   // Frame assembly l2_frame less or equal
    { 8'h01, // Version 8'h00,\n   // QoS 16'h0001, // Batch ID 48'hFFFFFFFFFFFF,
    // Dest MAC\n   48'hAABBCCDDEEFF, // Source MAC 16'h5W3K, // EtherType\n   merklesw103k_root,
    lz77_compress(havi_payload) }; end endmodule 3.3\n   Userspace Daemon (Go) go
    func processBatch(batch [103]HAVIPacket)\n   []byte { var buf bytes.Buffer //
    Build merklesw103k tree hashes :=\n   make([][]byte, 103) for i, pkt := range
    batch { hashes[i] =\n   sha3.Sum256(pkt.Serialize()) } root := buildmerklesw103kTree(hashes)\n
    \  // Compress comp := lz77.NewCompressor() for _, pkt := range batch {\n   comp.Write(pkt.Serialize())
    } // Construct L2 frame frame :=\n   SW103KFrame{ Version: 0x1, QoS: 0, BatchID:
    nextBatchID(), DstMAC:\n   net.HardwareAddr{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, SrcMAC:
    localMAC,\n   EtherType: 0x5W3K, merklesw103kRoot: root, Payload: comp.Finish(),
    }\n   return frame.Serialize() } 4.  Layer 2 Specific Features 4.1 MAC\n   Address
    Handling Multicast Address: 01:23:45:67:89:5W for control\n   frames Address Resolution:
    Custom ARP-like protocol using batch IDs\n   Promiscuous Mode: Special batch ID
    0xFFFF for monitoring 4.2 MTU\n   Considerations table Network Type | Standard
    MTU | SW103K Effective\n   MTU | Batch Capacity -------------------|--------------|-------------\n
    \  ---------|--------------- Ethernet | 1500 | 1486 | 103 packets @\n   14.4B
    each Wi-Fi 6 | 2304 | 2290 | 158 packets Industrial Ethernet|\n   9000 | 8986
    | 623 packets 5.  Layer 2 QoS Mechanisms 5.1 Priority\n   Classes text QoS Field
    Bits: 7 6 5 4 3 2 1 0\n   ┌───┬───┬───┬───┬───┬───┬───┬───┐ │ P │ P │ D │ E │
    R │ A │ T │ C │\n   └───┴───┴───┴───┴───┴───┴───┴───┘ P (2 bits): Priority (0-3)
    D: Drop\n   eligible E: Encryption requested R: Retransmission flag A:\n   Acknowledgment
    required T: Time-sensitive C: Congestion experienced\n   5.2 Traffic Shaping Example
    Diagram Code 6.  Layer 2 Security 6.1\n   Frame Protection Integrity: merklesw103k
    root covers entire batch\n   Confidentiality: Optional AES-256-GCM encryption
    (indicated in QoS\n   field) Replay Protection: Batch ID sequence validation 6.2
    Key\n   Exchange text EAP-SW103K Authentication Flow: 1.  Station →\n   Authenticator:
    EAPOL-Start 2.  Authenticator → Station: EAP-Request/\n   SW103K 3.  Station →
    Authenticator: EAP-Response/SW103K (contains\n   batch ID 0) 4.  Authenticator
    → Station: EAP-Success with PMK 7.\n   Interoperability with Layer 2 Technologies
    7.1 VLAN Tagging\n   Compatibility text Modified 802.1Q Header: 0 1 2 3 0 1 2
    3 4 5 6 7 8\n   9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   TPID 0x8100 | Priority |D|E| Batch ID |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Standard SW103K Header | 7.2 Industrial Protocol Mapping table\n   Protocol
    | SW103K Adaptation ------------|------------------\n   PROFINET | Batch ID →
    FrameID EtherCAT | HAVI as EtherCAT PDU OPC UA\n   PubSub| QoS → Publisher Priority
    8.  Physical Layer Considerations\n   8.1 Synchronization Requirements Timestamp
    Accuracy: ±1μs for HAVI\n   packets Jitter Tolerance: less than 50μs for QoS class
    3 Clock Sync:\n   1588 PTP with SW103K extension 8.2 Error Handling text Error
    Recovery\n   Process: 1.  Receive corrupted batch 2.  Send NAK with bitmap of
    bad\n   packets 3.  Retransmit only affected HAVI packets 4.  Recompute\n   merklesw103k
    root B.  Terminology Section Expand to include all key\n   terms with clear definitions:
    SW103K: The compression/transport\n   protocol HAVI: The packet format used by
    SW103K Compression Window:\n   Size of data blocks processed merkelsw103k Root:
    The integrity\n   verification mechanism 2.  Technical Depth Improvements A.  Protocol\n
    \  Specification Add detailed message formats for both protocols: SW103K\n   Header
    (16 bytes): 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\n   1 2 3 4 5 6
    7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Version | Flags | Packet Length |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   Compression Window |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |\n   merkelsw103k Root Hash |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    B.\n   State Machine Diagrams Include detailed state diagrams for:\n   Connection
    establishment Compression/decompression flows Error\n   recovery procedures C.
    \ Algorithm Specifications Provide pseudocode\n   for key algorithms: python def
    sw103k_compress(packets): # Step 1:\n   Batch 103 HAVI packets batch = packets[:103]
    # Step 2: Calculate\n   merkelsw103k tree merkelsw103k_root = calculate_merkelsw103k(batch)
    #\n   Step 3: Apply Expansionsuite hybrid compression compressed =\n   expansionsuite_compress(batch)
    return SW103KPacket(merkelsw103k_root,\n   compressed) 3.  Expansion Areas A.
    \ HAVI Packet Specification Add\n   detailed HAVI packet format: Header structure
    Payload constraints\n   Special packet types (control, ACK, etc.)  B.  Protocol
    Interactions\n   Document how SW103K and HAVI work together: How HAVI packets
    are\n   batched How headers are preserved during compression How integrity\n   verification
    works across batches C.  Performance Characteristics\n   Include expected performance
    metrics: Compression ratios for\n   different data types CPU/memory requirements
    Latency impacts 4.\n\n   Security Enhancements A.  Detailed Security Considerations
    Expand to\n   cover: Compression oracle attacks (CRIME/BREACH) merkelsw103k tree\n
    \  verification limitations Denial of service protections Key management\n   for
    encrypted streams B.  Security Protocol Options Define how to\n   integrate with:
    TLS for encrypted transport Cryptographic\n   authentication Perfect forward secrecy
    options 5.  Implementation\n   Guidance A.  Reference Implementation Provide more
    complete code\n   examples: c // Example SW103K compression int sw103k_compress(struct\n
    \  havi_packet* packets, int count, struct sw103k_packet* output) { if\n   (count
    != 103) return -EINVAL; // Calculate merkelsw103k root\n   calculate_merkelsw103k_root(packets,
    output->merkelsw103k_root); //\n   Compress packets lz77_huffman_compress(packets,\n
    \  output->compressed_data); return 0; } B.  Interoperability\n   Requirements
    Define must-implement features Specify optional\n   extensions Include compliance
    test vectors 6.  IANA Considerations\n   Expansion Reserve well-known ports if
    needed Register media types for\n   SW103K streams Define any needed code points
    or identifiers 7.\n   Appendices A.  Example Flows Complete end-to-end examples
    showing:\n   Connection setup Data transfer Error recovery Teardown B.  Comparison\n
    \  Tables Feature comparison with: QUIC HTTP/2 compression WebSocket\n   compression
    MQTT Improve Data Transfer Speeds: By compressing data\n   before transmission,
    the protocol reduces the volume of data that\n   needs to be transferred, which
    improves transfer speeds, especially\n   in networks where bandwidth is a bottleneck.
    \ Ensure Data Integrity:\n   In addition to compression, SW103k integrates error-checking\n
    \  mechanisms that ensure data arrives intact.  This helps mitigate\n   issues
    in unreliable network conditions where packet loss or\n   corruption might occur.
    \ Security Considerations: The protocol\n   incorporates optional encryption to
    provide confidentiality during\n   data transmission.  This is especially useful
    in scenarios where\n   sensitive data needs to be transferred, like financial
    transactions\n   or health data over potentially insecure networks.  How Does
    This\n   Protocol Work?  The SW103k protocol operates in a client-server\n   architecture,
    where the sender (client) compresses the payload using\n   a predefined compression
    algorithm before transmitting it to the\n   receiver (server).  The receiver then
    decompresses the data back into\n   its original form.  Key Components: Compression
    Algorithm: SW103k\n   uses a hybrid compression algorithm combining LZ77 and Huffman\n
    \  encoding, ensuring efficient data compression with minimal overhead.\n   The
    protocol negotiates the compression parameters (e.g., window\n   size) at the
    start of each connection.  Decompression Mechanism: The\n   receiver is responsible
    for decompressing the data using the same\n   parameters agreed upon during the
    initial handshake.  The\n   decompression process is optimized for low-latency
    environments to\n   ensure the data is available with minimal delay.  Transport
    Layer:\n   SW103k functions over standard transport layers such as TCP or QUIC,\n
    \  and adds a lightweight layer that manages compression, decompression,\n   and
    error-checking.  The protocol header contains metadata about the\n   compression
    type and error-checking mechanism used.  Error Checking:\n   SW103k includes a
    checksum or CRC32 in each transmission block,\n   ensuring that data corruption
    can be detected and retransmitted if\n   necessary.  Comparison with Other Transport
    Protocols Compared to\n   other transport protocols like TCP or QUIC, SW103k doesn’t
    replace\n   them but adds an additional layer of compression and decompression
    to\n   the transport process.  Unlike raw TCP or QUIC, which primarily focus\n
    \  on connection reliability and speed, SW103k introduces bandwidth\n   optimization
    through compression, which makes it particularly useful\n   in constrained environments.
    \ Here’s how SW103k compares with other\n   protocols: TCP: TCP provides reliable
    transmission, but it does not\n   natively compress data.  While you can use application-layer\n
    \  compression with TCP, SW103k integrates compression at the transport\n   layer,
    optimizing both compression and transmission.  QUIC: QUIC\n   focuses on speed
    and low-latency transmissions, especially over\n   unreliable networks.  SW103k
    could potentially be layered on top of\n   QUIC to introduce compression, making
    it useful in high-latency\n   networks like mobile or satellite.  TLS: TLS ensures
    security over\n   transmission but doesn’t compress data.  SW103k can work with
    TLS,\n   where compressed data is first encrypted before being transmitted,\n
    \  adding an additional layer of bandwidth efficiency.  SCTP: Like TCP,\n   SCTP
    focuses on reliability, especially for message-based\n   communications.  SW103k
    could work with SCTP when reliability and\n   bandwidth optimization are both
    critical.  Why Choose SW103k Over\n   Existing Protocols?  SW103k could be chosen
    over existing protocols\n   when: Bandwidth Optimization is Critical: In environments
    like IoT\n   networks, satellite communications, or mobile data transfer, where\n
    \  bandwidth is expensive or limited, SW103k reduces the overall data\n   transferred
    by compressing the payload before transmission.  Minimal\n   Processing Overhead:
    SW103k has been designed to offer high levels of\n   compression with low computational
    overhead, making it ideal for low-\n   power devices or systems with limited resources.
    \ Easy Integration\n   with Existing Protocols: SW103k is designed to work alongside\n
    \  existing transport protocols (e.g., TCP, QUIC) without needing major\n   architectural
    changes.  It acts as a lightweight add-on for\n   compression and decompression,
    simplifying adoption for legacy\n   systems.  Security Issues Raised by Using
    This Protocol Using the\n   SW103k protocol introduces a few potential security
    considerations:\n   Compression-related Attacks: Compression algorithms may be\n
    \  susceptible to attacks such as the CRIME or BREACH attacks, which\n   exploit
    the predictable nature of compressed data.  Implementing\n   padding or randomized
    inputs to the compression process could help\n   mitigate these risks.  Data Integrity
    and Tampering: Since the\n   protocol involves compressing and decompressing data,
    there's a risk\n   that data might be tampered with during transmission.  SW103k\n
    \  addresses this by incorporating checksum or CRC32 mechanisms to\n   verify
    the integrity of each transmission block.  Encryption\n   Considerations: If sensitive
    data is being transmitted using SW103k,\n   the protocol needs to ensure that
    the compression process doesn't\n   leak information about the original data.
    \ It’s recommended that data\n   be encrypted before compression or using TLS
    in conjunction with\n   SW103k for secure transmissions.  Denial-of-Service (DoS)\n
    \  Vulnerabilities: Malicious users could flood the server with\n   decompression
    requests, consuming significant CPU resources.\n   Implementing rate limiting
    or requiring authenticated connections\n   before processing requests can reduce
    the attack surface.  Concrete\n   Examples of What is Missing When I refer to
    the current document not\n   containing anything concrete, I mean that the draft
    lacks crucial\n   technical details and implementation guidance that protocol\n
    \  implementers or reviewers need to understand the protocol’s purpose\n   and
    function.  For example: Detailed Algorithm: Instead of just\n   saying “SW103k
    compresses data,” a concrete description would include\n   the actual algorithm
    (e.g., how the hybrid of LZ77 and Huffman\n   encoding works) and pseudocode to
    explain how compression and\n   decompression happen.  Message Formats: In protocols
    like HTTP/2 or\n   QUIC, message formats are clearly defined.  Each byte or bit
    has a\n   meaning in the headers, body, and control information.  SW103k should\n
    \  include message diagrams showing what the protocol header looks like,\n   how
    metadata is transmitted, etc.  State Machine or Flow Diagrams:\n   Many transport
    protocols include flow diagrams showing how the\n   protocol handles different
    network events (e.g., connection\n   initiation, packet retransmission).  SW103k
    should include this to\n   illustrate the typical lifecycle of a connection.  Code
    Examples:\n   Providing actual working code that developers could use to implement\n
    \  SW103k would be useful.  This could be a Python or C library that\n   demonstrates
    how compression is performed and how the protocol\n   interacts with the transport
    layer.  Conclusion: Actionable Next\n   Steps for Internet Draft To move forward
    with SW103k as an Internet\n   Draft for the IETF: Develop a Detailed Specification:
    Include the\n   detailed design and behavior of the protocol, including the\n
    \  compression algorithm, transport layer interaction, and flow control.\n   Provide
    Concrete Examples: Add sample pseudocode or protocol header\n   diagrams that
    illustrate how the protocol works in practice.\n   Security Considerations: Detail
    the potential risks (e.g., CRIME/\n   BREACH attacks) and provide mitigation strategies
    to secure the\n   protocol.  Test Cases and Implementation: Provide a reference\n
    \  implementation or a set of test cases for developers to try out the\n   protocol
    in different environments.\n\n\t "
relation:
- type: updates
  bibitem:
    formattedref: draft-rfcxml-rfc-swl-103k-02
    source:
    - type: src
      content: https://datatracker.ietf.org/doc/html/draft-rfcxml-rfc-swl-103k-02
    docidentifier:
    - content: draft-rfcxml-rfc-swl-103k-02
      type: Internet-Draft
      primary: true
- type: updatedBy
  bibitem:
    formattedref: draft-rfcxml-rfc-swl-103k-04
    source:
    - type: src
      content: https://datatracker.ietf.org/doc/html/draft-rfcxml-rfc-swl-103k-04
    docidentifier:
    - content: draft-rfcxml-rfc-swl-103k-04
      type: Internet-Draft
      primary: true
series:
- type: main
  title:
  - language: en
    script: Latn
    content: Internet-Draft
  number: draft-rfcxml-rfc-swl-103k-03
ext:
  schema_version: v1.0.1
  doctype:
    content: internet-draft
  flavor: ietf
