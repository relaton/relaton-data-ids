---
id: draftkunzepairtree01
type: standard
schema_version: v1.4.1
title:
- language: en
  script: Latn
  content: Pairtrees for Object Storage (V0.1) http://www.ietf.org/internet-drafts/draft-kunze-pairtree-01.txt
source:
- type: src
  content: https://datatracker.ietf.org/doc/html/draft-kunze-pairtree-01
docidentifier:
- content: draft-kunze-pairtree
  type: Internet-Draft
- content: draft-kunze-pairtree-01
  type: Internet-Draft
  primary: true
docnumber: I-D.kunze-pairtree
date:
- type: published
  at: '2008-11-26'
contributor:
- role:
  - type: author
  person:
    name:
      forename:
      - language: en
        script: Latn
        content: John
      - language: en
        script: Latn
        initial: J
      - language: en
        script: Latn
        initial: A
      formatted_initials:
        language: en
        content: J. A.
      surname:
        language: en
        content: Kunze
      completename:
        language: en
        content: John A. Kunze
    affiliation:
    - organization:
        name:
        - language: en
          content: California Digital Library
- role:
  - type: author
  person:
    name:
      forename:
      - language: en
        script: Latn
        content: Martin
      - language: en
        script: Latn
        initial: M
      formatted_initials:
        language: en
        content: M.
      surname:
        language: en
        content: Haye
      completename:
        language: en
        content: Martin Haye
    affiliation:
    - organization:
        name:
        - language: en
          content: California Digital Library
- role:
  - type: author
  person:
    name:
      forename:
      - language: en
        script: Latn
        content: Erik
      - language: en
        script: Latn
        initial: E
      formatted_initials:
        language: en
        content: E.
      surname:
        language: en
        content: Hetzner
      completename:
        language: en
        content: Erik Hetzner
    affiliation:
    - organization:
        name:
        - language: en
          content: California Digital Library
- role:
  - type: author
  person:
    name:
      forename:
      - language: en
        script: Latn
        content: Mark
      - language: en
        script: Latn
        initial: M
      formatted_initials:
        language: en
        content: M.
      surname:
        language: en
        content: Reyes
      completename:
        language: en
        content: Mark Reyes
    affiliation:
    - organization:
        name:
        - language: en
          content: California Digital Library
- role:
  - type: author
  person:
    name:
      forename:
      - language: en
        script: Latn
        content: Cory
      - language: en
        script: Latn
        initial: C
      formatted_initials:
        language: en
        content: C.
      surname:
        language: en
        content: Snavely
      completename:
        language: en
        content: Cory Snavely
    affiliation:
    - organization:
        name:
        - language: en
          content: University of Michigan Library IT
version:
- draft: '01'
language:
- en
script:
- Latn
abstract:
- language: en
  script: Latn
  content: "This document specifies Pairtree, a filesystem hierarchy for holding\nobjects
    that are located within that hierarchy by mapping identifier\nstrings to object
    directory (or folder) paths two characters at a\ntime.  If an object directory
    (folder) holds all the files, and\nnothing but the files, that comprise the object,
    a \"pairtree\" can be\nimported by a system that knows nothing about the nature
    or structure\nof the objects but can still deliver any object's files by requested\nidentifier.
    \ The mapping is reversible, so the importing system can\nalso walk the pairtree
    and reliably enumerate all the contained\nobject identifiers.  To the extent that
    object dependencies are\nstored inside the pairtree (e.g., fast indexes stored
    outside contain\nonly derivative data), simple or complex collections built on
    top of\npairtrees can recover from index failures and reconstruct a\ncollection
    view simply by walking the trees.  Pairtrees have the\nadvantage that many object
    operations, including backup and restore,\ncan be performed with native operating
    system tools.1.  The basic pairtree algorithm\n\nThe pairtree algorithm maps an
    arbitrary UTF-8 [RFC3629] encoded\nidentifier string into a filesystem directory
    path based on\nsuccessive pairs of characters, and also defines the reverse mapping\n(from
    pathname to identifier).\n\nIn this document the word \"directory\" is used interchangeably
    with\nthe word \"folder\" and all examples conform to Unix-based filesystem\nconventions
    which should tranlate easily to Windows conventions after\nsubstituting the path
    separator ('\\' instead of '/').  Pairtree\nplaces no limitations on file and
    path lengths, so implementors\nthinking about maximal interoperation may wish
    to consider the issues\nlisted in the Interoperability section of this document.\n\nThe
    mapping from identifier string to path has two parts.  First, the\nstring is cleaned
    by converting characters that would be illegal or\nespecially problemmatic in
    Unix or Windows filesystems.  The cleaned\nstring is then split into pairs of
    characters, each of which becomes\na directory name in a filesystem path: successive
    pairs map to\nsuccessive path components until there are no characters left, with\nthe
    last component being either a 1- or 2-character directory name.\nThe resulting
    path is known as a _pairpath_, or _ppath_.\n\nabcd\n\n-> ab/cd/\nabcdefg\n-> ab/cd/ef/g/\n12-986xy4
    -> 12/-9/86/xy/4/\n\nArmed with specific knowledge of a given namespace's identifier\ndistribution,
    one might achieve more balanced or efficient trees by\nmapping to paths from character
    groupings other than successive\npairs.  Pairtree assumes that this sort of optimization,
    however,\nbeing tailored to individual and transient namespace conditions, is\noften
    less important than having a single generalized and shareable\nmapping.  It uses
    pairs of characters to achieve hierarchies that\nexhibit a reasonable balance
    of path length and fanout (number of\nprobable entries in any component directory).2.
    \ Pairpath termination and object encapsulation\n\nA ppath (pairpath) terminates
    when it reaches an object.  A little\njargon helps explain this.  A _shorty_ is
    a 1- or 2-character\ndirectory name, or any file or directory name that begins
    with\n\"pairtree\" (these are reserved for future use).  A ppath consists of\na
    sequence of \"shorties\" ending in a non-shorty, such as a\n3-character directory
    name or the 2-character file name \"xy\".  The\npairtree below contains two objects
    with identifiers \"abcd\" and\n\"abcde\".\n\nab/\n|\n\\--- cd/\n\n  |\n\n  |---
    foo/\n\n  |\n |\nREADME.txt\n\n  |\n |\nthumbnail.gif\n\n  |\n |\n\n  |\n |---
    master_images/\n\n  |\n |\n |\n...\n\n  |\n |\n ...\n\n  |\n |\n\n  |\n \\---
    gh/\n\n  |\n\n  \\--- e/\n\n\n\n |\n\n\n\n \\--- bar/\n\n\n\n\n\n|\nmetadata\n\n\n\n\n\n|\n54321.wav\n\n\n\n\n\n|\nindex.html\n\nAn
    object is reached when a non-shorty is detected.  An object is\n_properly encapsulated_
    if it is entirely contained in a non-shorty\ndirectory that is the immediate child
    of a shorty directory, in other\nwords, if the 1- or 2-char directory name ending
    the object's ppath\ncontains exactly one non-shorty directory that holds all the
    object's\ndescendants.  The two objects \"abcd\" and \"abcde\" above are properly\nencapsulated.
    \ Any shorty directory found at the same level as the\nnon-shorty extends the
    pairtree.  So while the \"foo/\" directory above\ndoes not subsume \"e/\" at the
    same level, by encapsulation, it does\nsubsume the \"gh/\" underneath it (i.e.,
    \"gh/\" is invisible to the\npairtree algorithm, at least on a first pass).\n\nPractice
    will vary according to local custom as to how to name the\nencapsulating object
    directory beneath that last shorty.  Its name is\ncompletely independent of the
    object identifier.  For example, every\nobject directory in a pairtree could have
    the uniform name \"thingy\".\nIt is common for the directory name to be a terminal
    substring of the\nobject identifier, as in:\n\n\nid:  13030_45xqv_793842495\nppath:
    \ 13/03/0_/45/xq/v_/79/38/42/49/5/793842495\n\nAll objects should be properly
    encapsulated.  If an object is\ndetected that is _improperly encapsulated_, that
    is, when a ppath\nends with a shorty directory that contains more than one non-shorty,\nthe
    detecting system should take corrective action.  In this\nsituation, also known
    as a \"split end\", all those non-shorties\n(directories and files) are considered
    to belong to one object (not\nproperly encapsulated) identified by the containing
    ppath.  Excluding\nshorties from the object permits one identifier to be a substring
    of\nanother (e.g., \"abcd\" and \"abcde\" can co-exist in a pairtree), and\ndefining
    ppath termination in this way prevents \"hidden riders\", or\ndata residing in
    a pairtree that is not contained or accounted for in\nany object.  Here is an
    example of an improperly encapsulated object\nnamed \"bent\".\n\n\nbe/\n|\n\\---
    nt/\n\n\n\n\n[ split end: two files, no encapsulation ]\n\n  |\nREADME.txt\n\n
    \ |\nreport.pdf\n\n  |\n\n  \\--- ef/\n\n\n\n |\n...\n\nIf a \"split end\" is
    encountered, an importing system is encouraged to\nnormalize it by creating a
    single object directory called \"obj\" and\npushing the non-shorties in question
    underneath it, as in:\n\nbe/\n|\n\\--- nt/\n\n  |\n\n  |--- obj/\n\n  [ split
    end repaired with \"obj\" directory ]\n\n  |\n |\nREADME.txt\n\n  |\n |\nreport.pdf\n\n
    \ |\n\n  \\--- ef/\n\n\n\n |\n...\n\t "
series:
- type: main
  title:
  - language: en
    script: Latn
    content: Internet-Draft
  number: draft-kunze-pairtree-01
ext:
  schema_version: v1.0.1
  doctype:
    content: internet-draft
  flavor: ietf
